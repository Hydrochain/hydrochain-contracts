/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.17.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { InstantiateMsg, ExecuteMsg, ColorSpectrum, Uint128, Decimal, Coin, Coordinates, QueryMsg, Addr, Status, ContainerResponse, ShipmentDetails, ContainersResponse } from "./Hydrogen.types";
export interface HydrogenReadOnlyInterface {
  contractAddress: string;
  container: ({
    containerId
  }: {
    containerId: number;
  }) => Promise<ContainerResponse>;
  containers: () => Promise<ContainersResponse>;
  containersByOwner: ({
    owner
  }: {
    owner: string;
  }) => Promise<ContainersResponse>;
}
export class HydrogenQueryClient implements HydrogenReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.container = this.container.bind(this);
    this.containers = this.containers.bind(this);
    this.containersByOwner = this.containersByOwner.bind(this);
  }

  container = async ({
    containerId
  }: {
    containerId: number;
  }): Promise<ContainerResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      container: {
        container_id: containerId
      }
    });
  };
  containers = async (): Promise<ContainersResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      containers: {}
    });
  };
  containersByOwner = async ({
    owner
  }: {
    owner: string;
  }): Promise<ContainersResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      containers_by_owner: {
        owner
      }
    });
  };
}
export interface HydrogenInterface extends HydrogenReadOnlyInterface {
  contractAddress: string;
  sender: string;
  produce: ({
    colorSpectrum,
    price,
    volume
  }: {
    colorSpectrum: ColorSpectrum;
    price: Coin;
    volume: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updatePrice: ({
    containerId,
    newPrice
  }: {
    containerId: number;
    newPrice: Coin;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  buy: ({
    containerId,
    coordinates,
    destination
  }: {
    containerId: number;
    coordinates: Coordinates;
    destination: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  closeShipment: ({
    containerId
  }: {
    containerId: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  removeContainer: ({
    containerId
  }: {
    containerId: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
}
export class HydrogenClient extends HydrogenQueryClient implements HydrogenInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.produce = this.produce.bind(this);
    this.updatePrice = this.updatePrice.bind(this);
    this.buy = this.buy.bind(this);
    this.closeShipment = this.closeShipment.bind(this);
    this.removeContainer = this.removeContainer.bind(this);
  }

  produce = async ({
    colorSpectrum,
    price,
    volume
  }: {
    colorSpectrum: ColorSpectrum;
    price: Coin;
    volume: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      produce: {
        color_spectrum: colorSpectrum,
        price,
        volume
      }
    }, fee, memo, funds);
  };
  updatePrice = async ({
    containerId,
    newPrice
  }: {
    containerId: number;
    newPrice: Coin;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_price: {
        container_id: containerId,
        new_price: newPrice
      }
    }, fee, memo, funds);
  };
  buy = async ({
    containerId,
    coordinates,
    destination
  }: {
    containerId: number;
    coordinates: Coordinates;
    destination: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      buy: {
        container_id: containerId,
        coordinates,
        destination
      }
    }, fee, memo, funds);
  };
  closeShipment = async ({
    containerId
  }: {
    containerId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      close_shipment: {
        container_id: containerId
      }
    }, fee, memo, funds);
  };
  removeContainer = async ({
    containerId
  }: {
    containerId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_container: {
        container_id: containerId
      }
    }, fee, memo, funds);
  };
}